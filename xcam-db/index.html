
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XCam.Gay API/Data v1.16.0</title>
    <style>
        /* Estilos base conforme solicitado */
        body { 
            background: #121212; 
            color: white; 
            font-family: sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 20px; 
            margin: 0;
        }
        
        header { 
            margin-bottom: 20px; 
            text-align: center;
        }
        
        header h1 {
            color: #ff007f;
            margin-bottom: 5px;
        }
        
        header p {
            color: #aaa;
            margin-top: 0;
        }
        
        /* Logo do XCam */
        .logo {
            max-width: 200px;
            margin-bottom: 10px;
        }
        
        .container { 
            width: 100%; 
            max-width: 600px; 
        }
        
        .login-box, #mainBox { 
            background: #1a1a1a; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.3); 
            margin-bottom: 20px; 
        }
        
        .login-box input { 
            width: 100%; 
            padding: 10px; 
            margin: 8px 0; 
            border-radius: 4px; 
            border: 1px solid #333; 
            background: #121212; 
            color: #fff; 
            box-sizing: border-box;
        }
        
        /* Estilo para os botões */
        button { 
            display: block; 
            width: 100%; 
            background: linear-gradient(135deg,#ff007f,#800080); 
            border: none; 
            padding: 12px; 
            color: #fff; 
            font-size: 16px; 
            border-radius: 6px; 
            cursor: pointer; 
            margin-top: 10px; 
            transition: opacity 0.2s;
        }
        
        button:disabled { 
            opacity: 0.6; 
            cursor: not-allowed; 
        }
        
        /* Estilo para o botão de atualização automática */
        .auto-update-btn {
            background: #333;
            margin-left: 10px;
        }
        
        .auto-update-btn.active {
            background: linear-gradient(135deg, #00aa00, #008800);
        }
        
        /* Container para os botões de atualização */
        .update-buttons {
            display: flex;
            gap: 10px;
        }
        
        pre { 
            background: #111; 
            color: #0f0; 
            padding: 10px; 
            border-radius: 6px; 
            font-family: monospace; 
            height: 160px; 
            overflow-y: auto; 
            box-shadow: inset 0 0 10px #0f0; 
            margin-bottom: 20px; 
            width: 100%;
            box-sizing: border-box;
        }
        
        .user-card { 
            display: flex; 
            align-items: center; 
            background: #222; 
            padding: 10px; 
            border-radius: 6px; 
            margin-bottom: 8px; 
            transition: transform 0.2s;
        }
        
        .user-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .user-card img { 
            width: 40px; 
            height: 40px; 
            border-radius: 50%; 
            margin-right: 12px; 
            object-fit: cover;
        }
        
        .user-info {
            flex-grow: 1;
        }
        
        .user-name {
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .user-details {
            font-size: 12px;
            color: #aaa;
        }
        
        .user-card a { 
            margin-left: auto; 
            color: #66ccff; 
            text-decoration: none; 
            background: rgba(102, 204, 255, 0.1);
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .user-card a:hover {
            background: rgba(102, 204, 255, 0.2);
        }
        
        .download-link { 
            display: block; 
            text-align: center; 
            background: #0a0; 
            color: #fff; 
            padding: 10px; 
            border-radius: 6px; 
            text-decoration: none; 
            margin-top: 10px; 
        }
        
        dialog { 
            width: 90%; 
            max-width: 800px; /* Aumentado para acomodar o iframe */
            border: none; 
            border-radius: 8px; 
            padding: 0; 
            background: #1a1a1a;
            color: white;
        }
        
        /* Estilo para o iframe da transmissão */
        dialog iframe { 
            width: 100%; 
            height: 450px; /* Altura aumentada para o iframe */
            border-radius: 8px 8px 0 0; 
            border: none;
            display: block;
        }
        
        dialog::backdrop { 
            background: rgba(0,0,0,0.8); 
        }
        
        .dialog-content {
            padding: 15px;
        }
        
        .dialog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .dialog-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: auto;
            margin: 0;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .section-title {
            color: #ff007f;
            margin: 0;
        }
        
        .section-count {
            color: #aaa;
            font-size: 14px;
        }
        
        /* Estilos para filtros */
        .filter-section {
            background: #222;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            margin-bottom: 10px;
        }
        
        .filter-title {
            color: #ff007f;
            margin: 0;
        }
        
        .filter-toggle {
            transition: transform 0.3s;
        }
        
        .filter-toggle.open {
            transform: rotate(180deg);
        }
        
        .filter-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .filter-content.open {
            max-height: 500px;
        }
        
        .filter-row {
            margin-bottom: 10px;
        }
        
        .filter-label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
        }
        
        .filter-select, .filter-input {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #333;
            background: #121212;
            color: #fff;
            box-sizing: border-box;
        }
        
        .filter-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }
        
        .filter-apply {
            background: linear-gradient(135deg, #00aa00, #008800);
        }
        
        .filter-clear {
            background: #444;
        }
        
        .filter-badge {
            display: inline-block;
            background: #333;
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        
        .filter-badge button {
            background: none;
            border: none;
            color: #ff007f;
            cursor: pointer;
            padding: 0 0 0 5px;
            margin: 0;
            font-size: 14px;
            width: auto;
            display: inline;
        }
        
        /* Estilos para paginação */
        .pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
        }
        
        .pagination-info {
            color: #aaa;
            font-size: 14px;
        }
        
        .pagination-controls {
            display: flex;
            gap: 10px;
        }
        
        .pagination-button {
            background: #333;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
            width: auto;
            margin: 0;
        }
        
        .pagination-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination-current {
            background: #444;
            color: white;
            padding: 5px 15px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Indicador de atualização automática */
        .auto-update-indicator {
            display: inline-block;
            background: rgba(0, 170, 0, 0.2);
            color: #0a0;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 10px;
        }
        
        /* Animação de pulsação para o indicador */
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .auto-update-indicator.active {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <!-- Container de Login -->
    <div id="loginContainer" class="container">
        <header>
            <!-- Logo do XCam adicionado -->
            <img src="https://i.imgur.com/us22gEP.png" alt="XCam.Gay Logo" class="logo">
            <h1>XCam.Gay API/Data</h1>
            <p>Sistema de gerenciamento de dados</p>
        </header>
        
        <div class="login-box">
            <div>
                <label for="username">Usuário</label>
                <input type="text" id="username" placeholder="Digite seu usuário">
            </div>
            <div>
                <label for="password">Senha</label>
                <input type="password" id="password" placeholder="Digite sua senha">
            </div>
            <button id="loginBtn">Entrar</button>
            <p id="loginError" style="color: #ff007f; text-align: center; display: none;">Usuário ou senha inválidos</p>
        </div>
    </div>

    <!-- Container do Painel Principal -->
    <div id="dashboardContainer" class="container" style="display: none;">
        <header>
            <!-- Logo do XCam adicionado -->
            <img src="https://i.imgur.com/us22gEP.png" alt="XCam.Gay Logo" class="logo">
            <h1>XCam.Gay API/Data v1.16.0</h1>
            <p>Painel para gerenciamento e visualização de dados</p>
        </header>

        <!-- Botões de Atualização -->
        <div id="mainBox">
            <!-- Container para os botões de atualização -->
            <div class="update-buttons">
                <button id="updateBtn">Executar Atualização 🔄</button>
                <!-- Novo botão de atualização automática -->
                <button id="autoUpdateBtn" class="auto-update-btn">🔄 Atualizar Automaticamente</button>
            </div>
            
            <!-- Indicador de atualização automática -->
            <div id="autoUpdateIndicator" class="auto-update-indicator" style="display: none;">
                Atualização automática ativa - Próxima atualização em <span id="countdownTimer">10</span>s
            </div>
            
            <!-- Seção de Logs -->
            <div style="margin-top: 20px;">
                <div class="section-header">
                    <h3 class="section-title">Logs</h3>
                </div>
                <pre id="logs">Aguardando execução...</pre>
            </div>
        </div>

        <!-- Seção de Filtros -->
        <div class="filter-section">
            <div class="filter-header" id="filterToggle">
                <h3 class="filter-title">Filtros</h3>
                <span class="filter-toggle">▼</span>
            </div>
            
            <!-- Container de Filtros (inicialmente fechado) -->
            <div class="filter-content" id="filterContainer">
                <div class="filter-row">
                    <label class="filter-label" for="countryFilter">País</label>
                    <select id="countryFilter" class="filter-select">
                        <option value="">Todos os países</option>
                    </select>
                </div>
                
                <div class="filter-row">
                    <label class="filter-label" for="orientationFilter">Orientação Sexual</label>
                    <select id="orientationFilter" class="filter-select">
                        <option value="">Todas as orientações</option>
                    </select>
                </div>
                
                <div class="filter-row">
                    <label class="filter-label" for="tagsFilter">Tags</label>
                    <input type="text" id="tagsFilter" class="filter-input" placeholder="Separar tags por vírgula">
                </div>
                
                <!-- Área de Filtros Ativos -->
                <div id="activeFilters" style="margin-top: 10px;"></div>
                
                <div class="filter-actions">
                    <button id="clearFiltersBtn" class="filter-clear">Limpar</button>
                    <button id="applyFiltersBtn" class="filter-apply">Aplicar Filtros</button>
                </div>
            </div>
        </div>

        <!-- Seção de Transmissões -->
        <div id="mainBox">
            <div class="section-header">
                <h3 class="section-title">Transmissões</h3>
                <span id="streamCount" class="section-count">0 transmissões encontradas</span>
            </div>
            
            <!-- Container para os cards de transmissão -->
            <div id="streamsContainer">
                <!-- Os cards de transmissão serão inseridos aqui dinamicamente -->
            </div>
            
            <!-- Controles de Paginação -->
            <div class="pagination">
                <div class="pagination-info">
                    Mostrando <span id="showingFrom">0</span>-<span id="showingTo">0</span> de <span id="totalItems">0</span>
                </div>
                <div class="pagination-controls">
                    <button id="prevPageBtn" class="pagination-button" disabled>Anterior</button>
                    <span id="currentPage" class="pagination-current">1</span>
                    <button id="nextPageBtn" class="pagination-button" disabled>Próximo</button>
                </div>
            </div>
        </div>

        <!-- Seção de Download -->
        <div id="mainBox">
            <div class="section-header">
                <h3 class="section-title">Download</h3>
            </div>
            <p>Link para download do JSON atualizado:</p>
            <a id="downloadLink" href="#" target="_blank" class="download-link">Nenhum link disponível</a>
        </div>
    </div>

    <!-- Modal para Visualização de Transmissões -->
    <dialog id="streamModal">
        <div id="streamPlayer">
            <!-- O iframe será inserido aqui -->
        </div>
        <div class="dialog-content">
            <div class="dialog-header">
                <h3 id="modalUsername">Username</h3>
                <button class="dialog-close" id="closeModal">&times;</button>
            </div>
            <div id="modalDetails"></div>
        </div>
    </dialog>

    <script>
        // ==========================================
        // VARIÁVEIS GLOBAIS
        // ==========================================
        
        // Array para armazenar todas as transmissões carregadas da API
        let allStreams = [];
        
        // Array para armazenar as transmissões após aplicação dos filtros
        let filteredStreams = [];
        
        // Controle de paginação
        let currentPage = 1;
        const itemsPerPage = 30; // Número de itens por página
        
        // Objeto para armazenar os filtros ativos
        const activeFilters = {
            country: '',
            orientation: '',
            tags: []
        };
        
        // URL da API para buscar os dados
        const API_URL = 'https://api.xcam.gay/?limit=1500';
        
        // Variáveis para controle de atualização automática
        let autoUpdateEnabled = false;
        let autoUpdateInterval = null;
        let countdownValue = 10; // Tempo em segundos para atualização automática
        
        // ==========================================
        // ELEMENTOS DOM
        // ==========================================
        
        // Elementos da tela de login
        const loginContainer = document.getElementById('loginContainer');
        const dashboardContainer = document.getElementById('dashboardContainer');
        const loginBtn = document.getElementById('loginBtn');
        const loginError = document.getElementById('loginError');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        
        // Elementos do painel principal
        const updateBtn = document.getElementById('updateBtn');
        const autoUpdateBtn = document.getElementById('autoUpdateBtn'); // Novo botão de atualização automática
        const autoUpdateIndicator = document.getElementById('autoUpdateIndicator'); // Indicador de atualização automática
        const countdownTimer = document.getElementById('countdownTimer'); // Contador regressivo
        const logContainer = document.getElementById('logs');
        const streamsContainer = document.getElementById('streamsContainer');
        const downloadLink = document.getElementById('downloadLink');
        
        // Elementos do modal de visualização
        const streamModal = document.getElementById('streamModal');
        const closeModal = document.getElementById('closeModal');
        const streamPlayer = document.getElementById('streamPlayer');
        const modalUsername = document.getElementById('modalUsername');
        const modalDetails = document.getElementById('modalDetails');
        
        // Elementos de paginação
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const currentPageEl = document.getElementById('currentPage');
        const showingFrom = document.getElementById('showingFrom');
        const showingTo = document.getElementById('showingTo');
        const totalItems = document.getElementById('totalItems');
        const streamCount = document.getElementById('streamCount');
        
        // Elementos de filtro
        const filterToggle = document.getElementById('filterToggle');
        const filterContainer = document.getElementById('filterContainer');
        const countryFilter = document.getElementById('countryFilter');
        const orientationFilter = document.getElementById('orientationFilter');
        const tagsFilter = document.getElementById('tagsFilter');
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        const clearFiltersBtn = document.getElementById('clearFiltersBtn');
        const activeFiltersContainer = document.getElementById('activeFilters');

        // ==========================================
        // FUNCIONALIDADE DE LOGIN
        // ==========================================
        
        // Adiciona evento de clique ao botão de login
        loginBtn.addEventListener('click', handleLogin);
        
        // Permite pressionar Enter no campo de usuário para avançar para o campo de senha
        usernameInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') passwordInput.focus();
        });
        
        // Permite pressionar Enter no campo de senha para fazer login
        passwordInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') handleLogin();
        });

        /**
         * Função para validar o login do usuário
         * Verifica se o usuário e senha correspondem às credenciais esperadas
         */
        function handleLogin() {
            const username = usernameInput.value;
            const password = passwordInput.value;
            
            // Verifica as credenciais (admin/1234)
            if (username === 'admin' && password === '1234') {
                // Esconde o container de login e mostra o dashboard
                loginContainer.style.display = 'none';
                dashboardContainer.style.display = 'block';
                loginError.style.display = 'none';
            } else {
                // Mostra mensagem de erro
                loginError.style.display = 'block';
                passwordInput.value = '';
                passwordInput.focus();
            }
        }

        // ==========================================
        // FUNCIONALIDADE DE TOGGLE DE FILTROS
        // ==========================================
        
        // Adiciona evento de clique para expandir/colapsar a seção de filtros
        filterToggle.addEventListener('click', function() {
            filterContainer.classList.toggle('open');
            document.querySelector('.filter-toggle').classList.toggle('open');
        });

        // ==========================================
        // FUNCIONALIDADE DE ATUALIZAÇÃO DE DADOS
        // ==========================================
        
        // Adiciona evento de clique ao botão de atualização
        updateBtn.addEventListener('click', function() {
            // Desabilita o botão durante a atualização
            updateBtn.disabled = true;
            
            // Inicia o log
            logContainer.innerHTML = 'Iniciando atualização...\n';
            
            // Chama a função para buscar dados da API
            fetchDataFromAPI();
        });
        
        // ==========================================
        // FUNCIONALIDADE DE ATUALIZAÇÃO AUTOMÁTICA
        // ==========================================
        
        /**
         * Função para alternar o estado de atualização automática
         * Inicia ou para o intervalo de atualização automática
         */
        function toggleAutoUpdate() {
            autoUpdateEnabled = !autoUpdateEnabled;
            
            // Atualiza a aparência do botão
            if (autoUpdateEnabled) {
                autoUpdateBtn.classList.add('active');
                autoUpdateBtn.textContent = '🔄 Parar Atualização Automática';
                autoUpdateIndicator.style.display = 'block';
                autoUpdateIndicator.classList.add('active');
                
                // Inicia a contagem regressiva
                countdownValue = 10;
                countdownTimer.textContent = countdownValue;
                
                // Configura o intervalo para atualização automática
                autoUpdateInterval = setInterval(function() {
                    countdownValue--;
                    countdownTimer.textContent = countdownValue;
                    
                    // Quando o contador chegar a zero, atualiza os dados
                    if (countdownValue <= 0) {
                        // Reinicia o contador
                        countdownValue = 10;
                        countdownTimer.textContent = countdownValue;
                        
                        // Executa a atualização se o botão não estiver desabilitado
                        if (!updateBtn.disabled) {
                            appendToLog('Executando atualização automática...');
                            fetchDataFromAPI();
                        }
                    }
                }, 1000); // Atualiza o contador a cada segundo
            } else {
                // Desativa a atualização automática
                autoUpdateBtn.classList.remove('active');
                autoUpdateBtn.textContent = '🔄 Atualizar Automaticamente';
                autoUpdateIndicator.style.display = 'none';
                autoUpdateIndicator.classList.remove('active');
                
                // Limpa o intervalo
                if (autoUpdateInterval) {
                    clearInterval(autoUpdateInterval);
                    autoUpdateInterval = null;
                }
            }
        }
        
        // Adiciona evento de clique ao botão de atualização automática
        autoUpdateBtn.addEventListener('click', toggleAutoUpdate);

        /**
         * Função para buscar dados da API XCam
         * Utiliza um proxy CORS para evitar problemas de acesso cross-origin
         */
        function fetchDataFromAPI() {
            // Adiciona ao log que está buscando dados
            appendToLog('Buscando dados da API: ' + API_URL);
            
            // Faz a requisição para a API
            fetch(API_URL, {
                // Adiciona cabeçalhos para simular um navegador real
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                    'Accept': 'application/json'
                },
                // Define um timeout para a requisição
                signal: AbortSignal.timeout(30000) // 30 segundos de timeout
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Erro HTTP: ${response.status}`);
                }
                appendToLog('Dados recebidos com sucesso. Processando...');
                return response.json();
            })
            .then(data => {
                // Processa os dados recebidos
                processAPIData(data);
            })
            .catch(error => {
                // Trata erros na requisição
                appendToLog(`Erro ao buscar dados: ${error.message}`);
                
                // Se o erro for de CORS, sugere uma solução alternativa
                if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                    appendToLog('Este erro pode estar relacionado a restrições de CORS. Tente uma das seguintes soluções:');
                    appendToLog('1. Use uma extensão de navegador para desabilitar CORS temporariamente');
                    appendToLog('2. Configure um proxy CORS no servidor');
                    appendToLog('3. Utilize dados de exemplo para teste');
                    
                    // Carrega dados de exemplo para demonstração
                    appendToLog('\nCarregando dados de exemplo para demonstração...');
                    loadSampleData();
                }
                
                updateBtn.disabled = false;
            });
        }

        /**
         * Função para carregar dados de exemplo quando a API não está acessível
         * Cria um conjunto de dados fictícios para demonstração
         */
        function loadSampleData() {
            // Cria um objeto de dados de exemplo similar ao retornado pela API
            const sampleData = {
                broadcasts: {
                    total: 50,
                    page: 1,
                    totalPages: 1,
                    items: []
                }
            };
            
            // Cria 50 transmissões de exemplo
            const countries = ['br', 'us', 'es', 'fr', 'de', 'it', 'jp', 'ru', 'cn', 'au'];
            const orientations = ['straight', 'gay', 'bisexual', 'bicurious', 'pansexual'];
            const tagsList = [
                ['cum', 'bigcock'], 
                ['muscle', 'fitness'], 
                ['hairy', 'bear'], 
                ['latino', 'hot'], 
                ['young', '18'], 
                ['mature', 'daddy'],
                ['pornstar', 'professional'],
                ['fetish', 'bdsm'],
                ['uncut', 'foreskin']
            ];
            
            // Gera transmissões aleatórias
            for (let i = 1; i <= 50; i++) {
                const country = countries[Math.floor(Math.random() * countries.length)];
                const orientation = orientations[Math.floor(Math.random() * orientations.length)];
                const viewers = Math.floor(Math.random() * 1000) + 1;
                const selectedTags = tagsList[Math.floor(Math.random() * tagsList.length)];
                
                // Cria um objeto de transmissão
                const broadcast = {
                    XCamId: i,
                    id: `${10000 + i}`,
                    username: `user${i}`,
                    country: country,
                    sexualOrientation: orientation,
                    profileImageURL: `https://picsum.photos/id/${i + 100}/200/200`,
                    preview: {
                        src: null,
                        poster: `https://picsum.photos/id/${i + 200}/400/300`
                    },
                    viewers: viewers,
                    broadcastType: 'male',
                    gender: 'male',
                    tags: selectedTags.map(tag => ({ name: tag, slug: tag }))
                };
                
                sampleData.broadcasts.items.push(broadcast);
            }
            
            // Processa os dados de exemplo
            processAPIData(sampleData);
        }

        /**
         * Função para processar os dados recebidos da API
         * @param {Object} data - Objeto JSON recebido da API
         */
        function processAPIData(data) {
            try {
                // Verifica se os dados têm a estrutura esperada
                if (!data.broadcasts || !data.broadcasts.items) {
                    throw new Error('Formato de dados inválido');
                }
                
                // Extrai informações gerais
                const totalBroadcasts = data.broadcasts.total || 0;
                const broadcasts = data.broadcasts.items || [];
                
                // Adiciona informações ao log
                appendToLog(`Total de transmissões: ${totalBroadcasts}`);
                appendToLog(`Transmissões na página atual: ${broadcasts.length}`);
                
                // Limpa o array de transmissões
                allStreams = [];
                
                // Processa cada transmissão
                broadcasts.forEach((broadcast, index) => {
                    // Formata as tags para um formato mais simples
                    const formattedTags = broadcast.tags ? 
                        broadcast.tags.map(tag => tag.name) : 
                        [];
                    
                    // Cria um objeto com os dados relevantes da transmissão
                    const streamData = {
                        username: broadcast.username,
                        country: broadcast.country,
                        sexualOrientation: broadcast.sexualOrientation,
                        profileImageURL: broadcast.profileImageURL,
                        preview: broadcast.preview,
                        viewers: broadcast.viewers,
                        tags: formattedTags,
                        // Armazena o objeto broadcast completo para uso posterior
                        broadcastData: broadcast
                    };
                    
                    // Adiciona ao array de transmissões
                    allStreams.push(streamData);
                    
                    // Adiciona ao log (limitado a 10 para não sobrecarregar)
                    if (index < 10) {
                        appendToLog(`__STREAM__START__`);
                        appendToLog(JSON.stringify(streamData));
                        appendToLog(`__STREAM__END__`);
                    } else if (index === 10) {
                        appendToLog(`... mais ${broadcasts.length - 10} transmissões ...`);
                    }
                });
                
                // Simula um link de download (na implementação real, isso viria do backend)
                const downloadUrl = API_URL;
                appendToLog(`DOWNLOAD_JSON: ${downloadUrl}`);
                
                // Atualiza o link de download
                downloadLink.href = downloadUrl;
                downloadLink.textContent = 'Baixar JSON atualizado';
                
                // Popula as opções de filtro
                populateFilterOptions();
                
                // Reseta os filtros e exibe as transmissões
                resetFilters();
                applyFilters();
                
                // Finaliza a atualização
                appendToLog('Atualização concluída com sucesso!');
                updateBtn.disabled = false;
                
            } catch (error) {
                // Trata erros no processamento dos dados
                appendToLog(`Erro ao processar dados: ${error.message}`);
                updateBtn.disabled = false;
            }
        }

        /**
         * Função para adicionar texto ao log
         * @param {string} text - Texto a ser adicionado ao log
         */
        function appendToLog(text) {
            logContainer.innerHTML += text + '\n';
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // ==========================================
        // FUNCIONALIDADE DE FILTROS
        // ==========================================
        
        /**
         * Função para popular as opções de filtro com base nos dados das transmissões
         * Extrai países e orientações sexuais únicas para os dropdowns
         */
        function populateFilterOptions() {
            // Cria conjuntos para armazenar valores únicos
            const countries = new Set();
            const orientations = new Set();
            
            // Extrai valores únicos das transmissões
            allStreams.forEach(stream => {
                if (stream.country) countries.add(stream.country);
                if (stream.sexualOrientation) orientations.add(stream.sexualOrientation);
            });
            
            // Limpa as opções existentes, mantendo apenas a primeira (Todos)
            while (countryFilter.options.length > 1) {
                countryFilter.remove(1);
            }
            
            while (orientationFilter.options.length > 1) {
                orientationFilter.remove(1);
            }
            
            // Adiciona novas opções para países
            countries.forEach(country => {
                const option = document.createElement('option');
                option.value = country;
                option.textContent = country;
                countryFilter.appendChild(option);
            });
            
            // Adiciona novas opções para orientações sexuais
            orientations.forEach(orientation => {
                const option = document.createElement('option');
                option.value = orientation;
                option.textContent = orientation;
                orientationFilter.appendChild(option);
            });
        }

        /**
         * Função para aplicar os filtros às transmissões
         * Filtra com base no país, orientação sexual e tags selecionadas
         */
        function applyFilters() {
            const country = activeFilters.country;
            const orientation = activeFilters.orientation;
            const tags = activeFilters.tags;
            
            // Filtra as transmissões com base nos critérios selecionados
            filteredStreams = allStreams.filter(stream => {
                // Filtro de país
                if (country && stream.country !== country) return false;
                
                // Filtro de orientação sexual
                if (orientation && stream.sexualOrientation !== orientation) return false;
                
                // Filtro de tags
                if (tags.length > 0) {
                    if (!stream.tags || !Array.isArray(stream.tags)) return false;
                    
                    // Verifica se a transmissão tem pelo menos uma das tags especificadas
                    const hasMatchingTag = tags.some(tag => 
                        stream.tags.some(streamTag => 
                            streamTag.toLowerCase().includes(tag.toLowerCase())
                        )
                    );
                    
                    if (!hasMatchingTag) return false;
                }
                
                return true;
            });
            
            // Atualiza a contagem de transmissões
            streamCount.textContent = `${filteredStreams.length} transmissões encontradas`;
            totalItems.textContent = filteredStreams.length;
            
            // Reseta para a primeira página
            currentPage = 1;
            renderCurrentPage();
        }

        /**
         * Função para resetar todos os filtros
         * Limpa os campos de filtro e o objeto de filtros ativos
         */
        function resetFilters() {
            // Reseta os elementos de UI
            countryFilter.selectedIndex = 0;
            orientationFilter.selectedIndex = 0;
            tagsFilter.value = '';
            
            // Limpa o objeto de filtros ativos
            activeFilters.country = '';
            activeFilters.orientation = '';
            activeFilters.tags = [];
            
            // Atualiza a exibição de filtros ativos
            updateActiveFiltersDisplay();
        }

        /**
         * Função para atualizar a exibição de filtros ativos
         * Cria badges para cada filtro ativo
         */
        function updateActiveFiltersDisplay() {
            // Limpa o container de filtros ativos
            activeFiltersContainer.innerHTML = '';
            
            // Adiciona badge para o filtro de país, se ativo
            if (activeFilters.country) {
                addFilterBadge('País: ' + activeFilters.country, () => {
                    activeFilters.country = '';
                    countryFilter.selectedIndex = 0;
                    updateActiveFiltersDisplay();
                    applyFilters();
                });
            }
            
            // Adiciona badge para o filtro de orientação, se ativo
            if (activeFilters.orientation) {
                addFilterBadge('Orientação: ' + activeFilters.orientation, () => {
                    activeFilters.orientation = '';
                    orientationFilter.selectedIndex = 0;
                    updateActiveFiltersDisplay();
                    applyFilters();
                });
            }
            
            // Adiciona badges para cada tag, se houver
            activeFilters.tags.forEach(tag => {
                addFilterBadge('Tag: ' + tag, () => {
                    activeFilters.tags = activeFilters.tags.filter(t => t !== tag);
                    tagsFilter.value = activeFilters.tags.join(', ');
                    updateActiveFiltersDisplay();
                    applyFilters();
                });
            });
        }

        /**
         * Função para adicionar uma badge de filtro
         * @param {string} text - Texto a ser exibido na badge
         * @param {Function} removeCallback - Função a ser chamada quando a badge for removida
         */
        function addFilterBadge(text, removeCallback) {
            const badge = document.createElement('div');
            badge.className = 'filter-badge';
            badge.innerHTML = `
                ${text}
                <button class="remove-filter">×</button>
            `;
            badge.querySelector('.remove-filter').addEventListener('click', removeCallback);
            activeFiltersContainer.appendChild(badge);
        }

        // ==========================================
        // FUNCIONALIDADE DE PAGINAÇÃO
        // ==========================================
        
        /**
         * Função para renderizar a página atual de transmissões
         * Exibe os itens da página atual com base no índice de paginação
         */
        function renderCurrentPage() {
            // Calcula os índices de início e fim para a página atual
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, filteredStreams.length);
            const currentPageItems = filteredStreams.slice(startIndex, endIndex);
            
            // Atualiza as informações de paginação
            showingFrom.textContent = filteredStreams.length > 0 ? startIndex + 1 : 0;
            showingTo.textContent = endIndex;
            currentPageEl.textContent = currentPage;
            
            // Habilita/desabilita os botões de paginação
            prevPageBtn.disabled = currentPage === 1;
            nextPageBtn.disabled = endIndex >= filteredStreams.length;
            
            // Limpa o container de transmissões
            streamsContainer.innerHTML = '';
            
            // Adiciona os cards de transmissão
            currentPageItems.forEach(stream => {
                const card = createStreamCard(stream);
                streamsContainer.appendChild(card);
            });
            
            // Mostra mensagem se não houver transmissões
            if (currentPageItems.length === 0) {
                const noStreams = document.createElement('div');
                noStreams.style.textAlign = 'center';
                noStreams.style.padding = '20px';
                noStreams.style.color = '#aaa';
                noStreams.textContent = 'Nenhuma transmissão encontrada com os filtros atuais.';
                streamsContainer.appendChild(noStreams);
            }
        }

        /**
         * Função para criar um card de transmissão
         * @param {Object} stream - Objeto com dados da transmissão
         * @returns {HTMLElement} - Elemento DOM do card
         */
        function createStreamCard(stream) {
            // Cria o elemento do card
            const card = document.createElement('div');
            card.className = 'user-card';
            
            // Define valores padrão para propriedades que podem estar ausentes
            const profileImage = stream.profileImageURL || 'https://i.imgur.com/SL3HNQU.jpeg';
            const username = stream.username || 'Desconhecido';
            const viewers = stream.viewers || 0;
            const country = stream.country || 'Desconhecido';
            const orientation = stream.sexualOrientation || 'Não especificada';
            
            // Cria o HTML do card
            card.innerHTML = `
                <img src="${profileImage}" alt="${username}" onerror="this.src='https://i.imgur.com/SL3HNQU.jpeg'">
                <div class="user-info">
                    <div class="user-name">${username}</div>
                    <div class="user-details">
                        ${country} • ${orientation} • 👁️ ${viewers}
                    </div>
                </div>
                <a href="#" class="view-stream">Ver</a>
            `;
            
            // Adiciona evento de clique ao botão de visualização
            card.querySelector('.view-stream').addEventListener('click', (e) => {
                e.preventDefault();
                openStreamModal(stream);
            });
            
            return card;
        }

        // ==========================================
        // FUNCIONALIDADE DO MODAL DE TRANSMISSÃO
        // ==========================================
        
        /**
         * Função para abrir o modal de visualização de transmissão
         * @param {Object} stream - Objeto com dados da transmissão
         */
        function openStreamModal(stream) {
            // Define o nome de usuário no modal
            modalUsername.textContent = stream.username || 'Desconhecido';
            
            // Constrói os detalhes da transmissão
            let details = `
                <p><strong>País:</strong> ${stream.country || 'Desconhecido'}</p>
                <p><strong>Orientação:</strong> ${stream.sexualOrientation || 'Não especificada'}</p>
                <p><strong>Viewers:</strong> ${stream.viewers || 0}</p>
            `;
            
            // Adiciona tags, se disponíveis
            if (stream.tags && stream.tags.length > 0) {
                details += `<p><strong>Tags:</strong> ${stream.tags.join(', ')}</p>`;
            }
            
            // Adiciona dados completos do broadcast, se disponíveis
            if (stream.broadcastData) {
                details += `<p><strong>ID XCam:</strong> ${stream.broadcastData.XCamId || 'N/A'}</p>`;
                details += `<p><strong>Tipo de Transmissão:</strong> ${stream.broadcastData.broadcastType || 'N/A'}</p>`;
                details += `<p><strong>Gênero:</strong> ${stream.broadcastData.gender || 'N/A'}</p>`;
            }
            
            modalDetails.innerHTML = details;
            
            // Configura o player com iframe para a URL da transmissão
            streamPlayer.innerHTML = '';
            
            // Cria o iframe para a transmissão ao vivo
            const iframe = document.createElement('iframe');
            iframe.src = `https://xcam.gay/cam/?user=${stream.username}`;
            iframe.frameBorder = "0";
            iframe.allowFullscreen = true;
            iframe.allow = "autoplay; fullscreen";
            iframe.title = `Transmissão de ${stream.username}`;
            
            // Adiciona o iframe ao player
            streamPlayer.appendChild(iframe);
            
            // Mostra o modal
            streamModal.showModal();
        }

        // Fecha o modal quando o botão de fechar é clicado
        closeModal.addEventListener('click', function() {
            streamModal.close();
            
            // Limpa o conteúdo do player para interromper qualquer transmissão
            streamPlayer.innerHTML = '';
        });

        // ==========================================
        // CONTROLES DE PAGINAÇÃO
        // ==========================================
        
        // Botão de página anterior
        prevPageBtn.addEventListener('click', function() {
            if (currentPage > 1) {
                currentPage--;
                renderCurrentPage();
            }
        });

        // Botão de próxima página
        nextPageBtn.addEventListener('click', function() {
            if ((currentPage * itemsPerPage) < filteredStreams.length) {
                currentPage++;
                renderCurrentPage();
            }
        });

        // ==========================================
        // CONTROLES DE FILTRO
        // ==========================================
        
        // Botão para aplicar filtros
        applyFiltersBtn.addEventListener('click', function() {
            // Atualiza os filtros ativos com os valores selecionados
            activeFilters.country = countryFilter.value;
            activeFilters.orientation = orientationFilter.value;
            
            // Processa as tags (separadas por vírgula)
            const tagsText = tagsFilter.value.trim();
            activeFilters.tags = tagsText ? 
                tagsText.split(',').map(tag => tag.trim()).filter(tag => tag) : 
                [];
            
            // Atualiza a exibição de filtros e aplica os filtros
            updateActiveFiltersDisplay();
            applyFilters();
        });

        // Botão para limpar filtros
        clearFiltersBtn.addEventListener('click', function() {
            resetFilters();
            applyFilters();
        });

        // ==========================================
        // EVENTOS ADICIONAIS
        // ==========================================
        
        // Fecha o modal ao clicar no backdrop
        streamModal.addEventListener('click', function(event) {
            if (event.target === streamModal) {
                streamModal.close();
                
                // Limpa o conteúdo do player para interromper qualquer transmissão
                streamPlayer.innerHTML = '';
            }
        });

        // Inicializa com estado vazio
        resetFilters();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'942593a751fc0c61',t:'MTc0NzY3ODQ5Ni4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
