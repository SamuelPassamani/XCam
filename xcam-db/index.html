
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XCam.Gay API/Data v1.16.0</title>
    <style>
        /* Estilos base conforme solicitado */
        body { 
            background: #121212; 
            color: white; 
            font-family: sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 20px; 
            margin: 0;
        }
        
        header { 
            margin-bottom: 20px; 
            text-align: center;
        }
        
        header h1 {
            color: #ff007f;
            margin-bottom: 5px;
        }
        
        header p {
            color: #aaa;
            margin-top: 0;
        }
        
        /* Logo do XCam */
        .logo {
            max-width: 200px;
            margin-bottom: 10px;
        }
        
        .container { 
            width: 100%; 
            max-width: 600px; 
        }
        
        .login-box, #mainBox { 
            background: #1a1a1a; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.3); 
            margin-bottom: 20px; 
        }
        
        .login-box input { 
            width: 100%; 
            padding: 10px; 
            margin: 8px 0; 
            border-radius: 4px; 
            border: 1px solid #333; 
            background: #121212; 
            color: #fff; 
            box-sizing: border-box;
        }
        
        /* Estilo para os bot√µes */
        button { 
            display: block; 
            width: 100%; 
            background: linear-gradient(135deg,#ff007f,#800080); 
            border: none; 
            padding: 12px; 
            color: #fff; 
            font-size: 16px; 
            border-radius: 6px; 
            cursor: pointer; 
            margin-top: 10px; 
            transition: opacity 0.2s;
        }
        
        button:disabled { 
            opacity: 0.6; 
            cursor: not-allowed; 
        }
        
        /* Estilo para o bot√£o de atualiza√ß√£o autom√°tica */
        .auto-update-btn {
            background: #333;
            margin-left: 10px;
        }
        
        .auto-update-btn.active {
            background: linear-gradient(135deg, #00aa00, #008800);
        }
        
        /* Container para os bot√µes de atualiza√ß√£o */
        .update-buttons {
            display: flex;
            gap: 10px;
        }
        
        pre { 
            background: #111; 
            color: #0f0; 
            padding: 10px; 
            border-radius: 6px; 
            font-family: monospace; 
            height: 160px; 
            overflow-y: auto; 
            box-shadow: inset 0 0 10px #0f0; 
            margin-bottom: 20px; 
            width: 100%;
            box-sizing: border-box;
        }
        
        .user-card { 
            display: flex; 
            align-items: center; 
            background: #222; 
            padding: 10px; 
            border-radius: 6px; 
            margin-bottom: 8px; 
            transition: transform 0.2s;
        }
        
        .user-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .user-card img { 
            width: 40px; 
            height: 40px; 
            border-radius: 50%; 
            margin-right: 12px; 
            object-fit: cover;
        }
        
        .user-info {
            flex-grow: 1;
        }
        
        .user-name {
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .user-details {
            font-size: 12px;
            color: #aaa;
        }
        
        .user-card a { 
            margin-left: auto; 
            color: #66ccff; 
            text-decoration: none; 
            background: rgba(102, 204, 255, 0.1);
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .user-card a:hover {
            background: rgba(102, 204, 255, 0.2);
        }
        
        .download-link { 
            display: block; 
            text-align: center; 
            background: #0a0; 
            color: #fff; 
            padding: 10px; 
            border-radius: 6px; 
            text-decoration: none; 
            margin-top: 10px; 
        }
        
        dialog { 
            width: 90%; 
            max-width: 800px; /* Aumentado para acomodar o iframe */
            border: none; 
            border-radius: 8px; 
            padding: 0; 
            background: #1a1a1a;
            color: white;
        }
        
        /* Estilo para o iframe da transmiss√£o */
        dialog iframe { 
            width: 100%; 
            height: 450px; /* Altura aumentada para o iframe */
            border-radius: 8px 8px 0 0; 
            border: none;
            display: block;
        }
        
        dialog::backdrop { 
            background: rgba(0,0,0,0.8); 
        }
        
        .dialog-content {
            padding: 15px;
        }
        
        .dialog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .dialog-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: auto;
            margin: 0;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .section-title {
            color: #ff007f;
            margin: 0;
        }
        
        .section-count {
            color: #aaa;
            font-size: 14px;
        }
        
        /* Estilos para filtros */
        .filter-section {
            background: #222;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            margin-bottom: 10px;
        }
        
        .filter-title {
            color: #ff007f;
            margin: 0;
        }
        
        .filter-toggle {
            transition: transform 0.3s;
        }
        
        .filter-toggle.open {
            transform: rotate(180deg);
        }
        
        .filter-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .filter-content.open {
            max-height: 500px;
        }
        
        .filter-row {
            margin-bottom: 10px;
        }
        
        .filter-label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
        }
        
        .filter-select, .filter-input {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #333;
            background: #121212;
            color: #fff;
            box-sizing: border-box;
        }
        
        .filter-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }
        
        .filter-apply {
            background: linear-gradient(135deg, #00aa00, #008800);
        }
        
        .filter-clear {
            background: #444;
        }
        
        .filter-badge {
            display: inline-block;
            background: #333;
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        
        .filter-badge button {
            background: none;
            border: none;
            color: #ff007f;
            cursor: pointer;
            padding: 0 0 0 5px;
            margin: 0;
            font-size: 14px;
            width: auto;
            display: inline;
        }
        
        /* Estilos para pagina√ß√£o */
        .pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
        }
        
        .pagination-info {
            color: #aaa;
            font-size: 14px;
        }
        
        .pagination-controls {
            display: flex;
            gap: 10px;
        }
        
        .pagination-button {
            background: #333;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
            width: auto;
            margin: 0;
        }
        
        .pagination-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination-current {
            background: #444;
            color: white;
            padding: 5px 15px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Indicador de atualiza√ß√£o autom√°tica */
        .auto-update-indicator {
            display: inline-block;
            background: rgba(0, 170, 0, 0.2);
            color: #0a0;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 10px;
        }
        
        /* Anima√ß√£o de pulsa√ß√£o para o indicador */
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .auto-update-indicator.active {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <!-- Container de Login -->
    <div id="loginContainer" class="container">
        <header>
            <!-- Logo do XCam adicionado -->
            <img src="https://i.imgur.com/us22gEP.png" alt="XCam.Gay Logo" class="logo">
            <h1>XCam.Gay API/Data</h1>
            <p>Sistema de gerenciamento de dados</p>
        </header>
        
        <div class="login-box">
            <div>
                <label for="username">Usu√°rio</label>
                <input type="text" id="username" placeholder="Digite seu usu√°rio">
            </div>
            <div>
                <label for="password">Senha</label>
                <input type="password" id="password" placeholder="Digite sua senha">
            </div>
            <button id="loginBtn">Entrar</button>
            <p id="loginError" style="color: #ff007f; text-align: center; display: none;">Usu√°rio ou senha inv√°lidos</p>
        </div>
    </div>

    <!-- Container do Painel Principal -->
    <div id="dashboardContainer" class="container" style="display: none;">
        <header>
            <!-- Logo do XCam adicionado -->
            <img src="https://i.imgur.com/us22gEP.png" alt="XCam.Gay Logo" class="logo">
            <h1>XCam.Gay API/Data v1.16.0</h1>
            <p>Painel para gerenciamento e visualiza√ß√£o de dados</p>
        </header>

        <!-- Bot√µes de Atualiza√ß√£o -->
        <div id="mainBox">
            <!-- Container para os bot√µes de atualiza√ß√£o -->
            <div class="update-buttons">
                <button id="updateBtn">Executar Atualiza√ß√£o üîÑ</button>
                <!-- Novo bot√£o de atualiza√ß√£o autom√°tica -->
                <button id="autoUpdateBtn" class="auto-update-btn">üîÑ Atualizar Automaticamente</button>
            </div>
            
            <!-- Indicador de atualiza√ß√£o autom√°tica -->
            <div id="autoUpdateIndicator" class="auto-update-indicator" style="display: none;">
                Atualiza√ß√£o autom√°tica ativa - Pr√≥xima atualiza√ß√£o em <span id="countdownTimer">10</span>s
            </div>
            
            <!-- Se√ß√£o de Logs -->
            <div style="margin-top: 20px;">
                <div class="section-header">
                    <h3 class="section-title">Logs</h3>
                </div>
                <pre id="logs">Aguardando execu√ß√£o...</pre>
            </div>
        </div>

        <!-- Se√ß√£o de Filtros -->
        <div class="filter-section">
            <div class="filter-header" id="filterToggle">
                <h3 class="filter-title">Filtros</h3>
                <span class="filter-toggle">‚ñº</span>
            </div>
            
            <!-- Container de Filtros (inicialmente fechado) -->
            <div class="filter-content" id="filterContainer">
                <div class="filter-row">
                    <label class="filter-label" for="countryFilter">Pa√≠s</label>
                    <select id="countryFilter" class="filter-select">
                        <option value="">Todos os pa√≠ses</option>
                    </select>
                </div>
                
                <div class="filter-row">
                    <label class="filter-label" for="orientationFilter">Orienta√ß√£o Sexual</label>
                    <select id="orientationFilter" class="filter-select">
                        <option value="">Todas as orienta√ß√µes</option>
                    </select>
                </div>
                
                <div class="filter-row">
                    <label class="filter-label" for="tagsFilter">Tags</label>
                    <input type="text" id="tagsFilter" class="filter-input" placeholder="Separar tags por v√≠rgula">
                </div>
                
                <!-- √Årea de Filtros Ativos -->
                <div id="activeFilters" style="margin-top: 10px;"></div>
                
                <div class="filter-actions">
                    <button id="clearFiltersBtn" class="filter-clear">Limpar</button>
                    <button id="applyFiltersBtn" class="filter-apply">Aplicar Filtros</button>
                </div>
            </div>
        </div>

        <!-- Se√ß√£o de Transmiss√µes -->
        <div id="mainBox">
            <div class="section-header">
                <h3 class="section-title">Transmiss√µes</h3>
                <span id="streamCount" class="section-count">0 transmiss√µes encontradas</span>
            </div>
            
            <!-- Container para os cards de transmiss√£o -->
            <div id="streamsContainer">
                <!-- Os cards de transmiss√£o ser√£o inseridos aqui dinamicamente -->
            </div>
            
            <!-- Controles de Pagina√ß√£o -->
            <div class="pagination">
                <div class="pagination-info">
                    Mostrando <span id="showingFrom">0</span>-<span id="showingTo">0</span> de <span id="totalItems">0</span>
                </div>
                <div class="pagination-controls">
                    <button id="prevPageBtn" class="pagination-button" disabled>Anterior</button>
                    <span id="currentPage" class="pagination-current">1</span>
                    <button id="nextPageBtn" class="pagination-button" disabled>Pr√≥ximo</button>
                </div>
            </div>
        </div>

        <!-- Se√ß√£o de Download -->
        <div id="mainBox">
            <div class="section-header">
                <h3 class="section-title">Download</h3>
            </div>
            <p>Link para download do JSON atualizado:</p>
            <a id="downloadLink" href="#" target="_blank" class="download-link">Nenhum link dispon√≠vel</a>
        </div>
    </div>

    <!-- Modal para Visualiza√ß√£o de Transmiss√µes -->
    <dialog id="streamModal">
        <div id="streamPlayer">
            <!-- O iframe ser√° inserido aqui -->
        </div>
        <div class="dialog-content">
            <div class="dialog-header">
                <h3 id="modalUsername">Username</h3>
                <button class="dialog-close" id="closeModal">&times;</button>
            </div>
            <div id="modalDetails"></div>
        </div>
    </dialog>

    <script>
        // ==========================================
        // VARI√ÅVEIS GLOBAIS
        // ==========================================
        
        // Array para armazenar todas as transmiss√µes carregadas da API
        let allStreams = [];
        
        // Array para armazenar as transmiss√µes ap√≥s aplica√ß√£o dos filtros
        let filteredStreams = [];
        
        // Controle de pagina√ß√£o
        let currentPage = 1;
        const itemsPerPage = 30; // N√∫mero de itens por p√°gina
        
        // Objeto para armazenar os filtros ativos
        const activeFilters = {
            country: '',
            orientation: '',
            tags: []
        };
        
        // URL da API para buscar os dados
        const API_URL = 'https://api.xcam.gay/?limit=1500';
        
        // Vari√°veis para controle de atualiza√ß√£o autom√°tica
        let autoUpdateEnabled = false;
        let autoUpdateInterval = null;
        let countdownValue = 10; // Tempo em segundos para atualiza√ß√£o autom√°tica
        
        // ==========================================
        // ELEMENTOS DOM
        // ==========================================
        
        // Elementos da tela de login
        const loginContainer = document.getElementById('loginContainer');
        const dashboardContainer = document.getElementById('dashboardContainer');
        const loginBtn = document.getElementById('loginBtn');
        const loginError = document.getElementById('loginError');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        
        // Elementos do painel principal
        const updateBtn = document.getElementById('updateBtn');
        const autoUpdateBtn = document.getElementById('autoUpdateBtn'); // Novo bot√£o de atualiza√ß√£o autom√°tica
        const autoUpdateIndicator = document.getElementById('autoUpdateIndicator'); // Indicador de atualiza√ß√£o autom√°tica
        const countdownTimer = document.getElementById('countdownTimer'); // Contador regressivo
        const logContainer = document.getElementById('logs');
        const streamsContainer = document.getElementById('streamsContainer');
        const downloadLink = document.getElementById('downloadLink');
        
        // Elementos do modal de visualiza√ß√£o
        const streamModal = document.getElementById('streamModal');
        const closeModal = document.getElementById('closeModal');
        const streamPlayer = document.getElementById('streamPlayer');
        const modalUsername = document.getElementById('modalUsername');
        const modalDetails = document.getElementById('modalDetails');
        
        // Elementos de pagina√ß√£o
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const currentPageEl = document.getElementById('currentPage');
        const showingFrom = document.getElementById('showingFrom');
        const showingTo = document.getElementById('showingTo');
        const totalItems = document.getElementById('totalItems');
        const streamCount = document.getElementById('streamCount');
        
        // Elementos de filtro
        const filterToggle = document.getElementById('filterToggle');
        const filterContainer = document.getElementById('filterContainer');
        const countryFilter = document.getElementById('countryFilter');
        const orientationFilter = document.getElementById('orientationFilter');
        const tagsFilter = document.getElementById('tagsFilter');
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        const clearFiltersBtn = document.getElementById('clearFiltersBtn');
        const activeFiltersContainer = document.getElementById('activeFilters');

        // ==========================================
        // FUNCIONALIDADE DE LOGIN
        // ==========================================
        
        // Adiciona evento de clique ao bot√£o de login
        loginBtn.addEventListener('click', handleLogin);
        
        // Permite pressionar Enter no campo de usu√°rio para avan√ßar para o campo de senha
        usernameInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') passwordInput.focus();
        });
        
        // Permite pressionar Enter no campo de senha para fazer login
        passwordInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') handleLogin();
        });

        /**
         * Fun√ß√£o para validar o login do usu√°rio
         * Verifica se o usu√°rio e senha correspondem √†s credenciais esperadas
         */
        function handleLogin() {
            const username = usernameInput.value;
            const password = passwordInput.value;
            
            // Verifica as credenciais (admin/1234)
            if (username === 'admin' && password === '1234') {
                // Esconde o container de login e mostra o dashboard
                loginContainer.style.display = 'none';
                dashboardContainer.style.display = 'block';
                loginError.style.display = 'none';
            } else {
                // Mostra mensagem de erro
                loginError.style.display = 'block';
                passwordInput.value = '';
                passwordInput.focus();
            }
        }

        // ==========================================
        // FUNCIONALIDADE DE TOGGLE DE FILTROS
        // ==========================================
        
        // Adiciona evento de clique para expandir/colapsar a se√ß√£o de filtros
        filterToggle.addEventListener('click', function() {
            filterContainer.classList.toggle('open');
            document.querySelector('.filter-toggle').classList.toggle('open');
        });

        // ==========================================
        // FUNCIONALIDADE DE ATUALIZA√á√ÉO DE DADOS
        // ==========================================
        
        // Adiciona evento de clique ao bot√£o de atualiza√ß√£o
        updateBtn.addEventListener('click', function() {
            // Desabilita o bot√£o durante a atualiza√ß√£o
            updateBtn.disabled = true;
            
            // Inicia o log
            logContainer.innerHTML = 'Iniciando atualiza√ß√£o...\n';
            
            // Chama a fun√ß√£o para buscar dados da API
            fetchDataFromAPI();
        });
        
        // ==========================================
        // FUNCIONALIDADE DE ATUALIZA√á√ÉO AUTOM√ÅTICA
        // ==========================================
        
        /**
         * Fun√ß√£o para alternar o estado de atualiza√ß√£o autom√°tica
         * Inicia ou para o intervalo de atualiza√ß√£o autom√°tica
         */
        function toggleAutoUpdate() {
            autoUpdateEnabled = !autoUpdateEnabled;
            
            // Atualiza a apar√™ncia do bot√£o
            if (autoUpdateEnabled) {
                autoUpdateBtn.classList.add('active');
                autoUpdateBtn.textContent = 'üîÑ Parar Atualiza√ß√£o Autom√°tica';
                autoUpdateIndicator.style.display = 'block';
                autoUpdateIndicator.classList.add('active');
                
                // Inicia a contagem regressiva
                countdownValue = 10;
                countdownTimer.textContent = countdownValue;
                
                // Configura o intervalo para atualiza√ß√£o autom√°tica
                autoUpdateInterval = setInterval(function() {
                    countdownValue--;
                    countdownTimer.textContent = countdownValue;
                    
                    // Quando o contador chegar a zero, atualiza os dados
                    if (countdownValue <= 0) {
                        // Reinicia o contador
                        countdownValue = 10;
                        countdownTimer.textContent = countdownValue;
                        
                        // Executa a atualiza√ß√£o se o bot√£o n√£o estiver desabilitado
                        if (!updateBtn.disabled) {
                            appendToLog('Executando atualiza√ß√£o autom√°tica...');
                            fetchDataFromAPI();
                        }
                    }
                }, 1000); // Atualiza o contador a cada segundo
            } else {
                // Desativa a atualiza√ß√£o autom√°tica
                autoUpdateBtn.classList.remove('active');
                autoUpdateBtn.textContent = 'üîÑ Atualizar Automaticamente';
                autoUpdateIndicator.style.display = 'none';
                autoUpdateIndicator.classList.remove('active');
                
                // Limpa o intervalo
                if (autoUpdateInterval) {
                    clearInterval(autoUpdateInterval);
                    autoUpdateInterval = null;
                }
            }
        }
        
        // Adiciona evento de clique ao bot√£o de atualiza√ß√£o autom√°tica
        autoUpdateBtn.addEventListener('click', toggleAutoUpdate);

        /**
         * Fun√ß√£o para buscar dados da API XCam
         * Utiliza um proxy CORS para evitar problemas de acesso cross-origin
         */
        function fetchDataFromAPI() {
            // Adiciona ao log que est√° buscando dados
            appendToLog('Buscando dados da API: ' + API_URL);
            
            // Faz a requisi√ß√£o para a API
            fetch(API_URL, {
                // Adiciona cabe√ßalhos para simular um navegador real
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                    'Accept': 'application/json'
                },
                // Define um timeout para a requisi√ß√£o
                signal: AbortSignal.timeout(30000) // 30 segundos de timeout
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Erro HTTP: ${response.status}`);
                }
                appendToLog('Dados recebidos com sucesso. Processando...');
                return response.json();
            })
            .then(data => {
                // Processa os dados recebidos
                processAPIData(data);
            })
            .catch(error => {
                // Trata erros na requisi√ß√£o
                appendToLog(`Erro ao buscar dados: ${error.message}`);
                
                // Se o erro for de CORS, sugere uma solu√ß√£o alternativa
                if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                    appendToLog('Este erro pode estar relacionado a restri√ß√µes de CORS. Tente uma das seguintes solu√ß√µes:');
                    appendToLog('1. Use uma extens√£o de navegador para desabilitar CORS temporariamente');
                    appendToLog('2. Configure um proxy CORS no servidor');
                    appendToLog('3. Utilize dados de exemplo para teste');
                    
                    // Carrega dados de exemplo para demonstra√ß√£o
                    appendToLog('\nCarregando dados de exemplo para demonstra√ß√£o...');
                    loadSampleData();
                }
                
                updateBtn.disabled = false;
            });
        }

        /**
         * Fun√ß√£o para carregar dados de exemplo quando a API n√£o est√° acess√≠vel
         * Cria um conjunto de dados fict√≠cios para demonstra√ß√£o
         */
        function loadSampleData() {
            // Cria um objeto de dados de exemplo similar ao retornado pela API
            const sampleData = {
                broadcasts: {
                    total: 50,
                    page: 1,
                    totalPages: 1,
                    items: []
                }
            };
            
            // Cria 50 transmiss√µes de exemplo
            const countries = ['br', 'us', 'es', 'fr', 'de', 'it', 'jp', 'ru', 'cn', 'au'];
            const orientations = ['straight', 'gay', 'bisexual', 'bicurious', 'pansexual'];
            const tagsList = [
                ['cum', 'bigcock'], 
                ['muscle', 'fitness'], 
                ['hairy', 'bear'], 
                ['latino', 'hot'], 
                ['young', '18'], 
                ['mature', 'daddy'],
                ['pornstar', 'professional'],
                ['fetish', 'bdsm'],
                ['uncut', 'foreskin']
            ];
            
            // Gera transmiss√µes aleat√≥rias
            for (let i = 1; i <= 50; i++) {
                const country = countries[Math.floor(Math.random() * countries.length)];
                const orientation = orientations[Math.floor(Math.random() * orientations.length)];
                const viewers = Math.floor(Math.random() * 1000) + 1;
                const selectedTags = tagsList[Math.floor(Math.random() * tagsList.length)];
                
                // Cria um objeto de transmiss√£o
                const broadcast = {
                    XCamId: i,
                    id: `${10000 + i}`,
                    username: `user${i}`,
                    country: country,
                    sexualOrientation: orientation,
                    profileImageURL: `https://picsum.photos/id/${i + 100}/200/200`,
                    preview: {
                        src: null,
                        poster: `https://picsum.photos/id/${i + 200}/400/300`
                    },
                    viewers: viewers,
                    broadcastType: 'male',
                    gender: 'male',
                    tags: selectedTags.map(tag => ({ name: tag, slug: tag }))
                };
                
                sampleData.broadcasts.items.push(broadcast);
            }
            
            // Processa os dados de exemplo
            processAPIData(sampleData);
        }

        /**
         * Fun√ß√£o para processar os dados recebidos da API
         * @param {Object} data - Objeto JSON recebido da API
         */
        function processAPIData(data) {
            try {
                // Verifica se os dados t√™m a estrutura esperada
                if (!data.broadcasts || !data.broadcasts.items) {
                    throw new Error('Formato de dados inv√°lido');
                }
                
                // Extrai informa√ß√µes gerais
                const totalBroadcasts = data.broadcasts.total || 0;
                const broadcasts = data.broadcasts.items || [];
                
                // Adiciona informa√ß√µes ao log
                appendToLog(`Total de transmiss√µes: ${totalBroadcasts}`);
                appendToLog(`Transmiss√µes na p√°gina atual: ${broadcasts.length}`);
                
                // Limpa o array de transmiss√µes
                allStreams = [];
                
                // Processa cada transmiss√£o
                broadcasts.forEach((broadcast, index) => {
                    // Formata as tags para um formato mais simples
                    const formattedTags = broadcast.tags ? 
                        broadcast.tags.map(tag => tag.name) : 
                        [];
                    
                    // Cria um objeto com os dados relevantes da transmiss√£o
                    const streamData = {
                        username: broadcast.username,
                        country: broadcast.country,
                        sexualOrientation: broadcast.sexualOrientation,
                        profileImageURL: broadcast.profileImageURL,
                        preview: broadcast.preview,
                        viewers: broadcast.viewers,
                        tags: formattedTags,
                        // Armazena o objeto broadcast completo para uso posterior
                        broadcastData: broadcast
                    };
                    
                    // Adiciona ao array de transmiss√µes
                    allStreams.push(streamData);
                    
                    // Adiciona ao log (limitado a 10 para n√£o sobrecarregar)
                    if (index < 10) {
                        appendToLog(`__STREAM__START__`);
                        appendToLog(JSON.stringify(streamData));
                        appendToLog(`__STREAM__END__`);
                    } else if (index === 10) {
                        appendToLog(`... mais ${broadcasts.length - 10} transmiss√µes ...`);
                    }
                });
                
                // Simula um link de download (na implementa√ß√£o real, isso viria do backend)
                const downloadUrl = API_URL;
                appendToLog(`DOWNLOAD_JSON: ${downloadUrl}`);
                
                // Atualiza o link de download
                downloadLink.href = downloadUrl;
                downloadLink.textContent = 'Baixar JSON atualizado';
                
                // Popula as op√ß√µes de filtro
                populateFilterOptions();
                
                // Reseta os filtros e exibe as transmiss√µes
                resetFilters();
                applyFilters();
                
                // Finaliza a atualiza√ß√£o
                appendToLog('Atualiza√ß√£o conclu√≠da com sucesso!');
                updateBtn.disabled = false;
                
            } catch (error) {
                // Trata erros no processamento dos dados
                appendToLog(`Erro ao processar dados: ${error.message}`);
                updateBtn.disabled = false;
            }
        }

        /**
         * Fun√ß√£o para adicionar texto ao log
         * @param {string} text - Texto a ser adicionado ao log
         */
        function appendToLog(text) {
            logContainer.innerHTML += text + '\n';
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // ==========================================
        // FUNCIONALIDADE DE FILTROS
        // ==========================================
        
        /**
         * Fun√ß√£o para popular as op√ß√µes de filtro com base nos dados das transmiss√µes
         * Extrai pa√≠ses e orienta√ß√µes sexuais √∫nicas para os dropdowns
         */
        function populateFilterOptions() {
            // Cria conjuntos para armazenar valores √∫nicos
            const countries = new Set();
            const orientations = new Set();
            
            // Extrai valores √∫nicos das transmiss√µes
            allStreams.forEach(stream => {
                if (stream.country) countries.add(stream.country);
                if (stream.sexualOrientation) orientations.add(stream.sexualOrientation);
            });
            
            // Limpa as op√ß√µes existentes, mantendo apenas a primeira (Todos)
            while (countryFilter.options.length > 1) {
                countryFilter.remove(1);
            }
            
            while (orientationFilter.options.length > 1) {
                orientationFilter.remove(1);
            }
            
            // Adiciona novas op√ß√µes para pa√≠ses
            countries.forEach(country => {
                const option = document.createElement('option');
                option.value = country;
                option.textContent = country;
                countryFilter.appendChild(option);
            });
            
            // Adiciona novas op√ß√µes para orienta√ß√µes sexuais
            orientations.forEach(orientation => {
                const option = document.createElement('option');
                option.value = orientation;
                option.textContent = orientation;
                orientationFilter.appendChild(option);
            });
        }

        /**
         * Fun√ß√£o para aplicar os filtros √†s transmiss√µes
         * Filtra com base no pa√≠s, orienta√ß√£o sexual e tags selecionadas
         */
        function applyFilters() {
            const country = activeFilters.country;
            const orientation = activeFilters.orientation;
            const tags = activeFilters.tags;
            
            // Filtra as transmiss√µes com base nos crit√©rios selecionados
            filteredStreams = allStreams.filter(stream => {
                // Filtro de pa√≠s
                if (country && stream.country !== country) return false;
                
                // Filtro de orienta√ß√£o sexual
                if (orientation && stream.sexualOrientation !== orientation) return false;
                
                // Filtro de tags
                if (tags.length > 0) {
                    if (!stream.tags || !Array.isArray(stream.tags)) return false;
                    
                    // Verifica se a transmiss√£o tem pelo menos uma das tags especificadas
                    const hasMatchingTag = tags.some(tag => 
                        stream.tags.some(streamTag => 
                            streamTag.toLowerCase().includes(tag.toLowerCase())
                        )
                    );
                    
                    if (!hasMatchingTag) return false;
                }
                
                return true;
            });
            
            // Atualiza a contagem de transmiss√µes
            streamCount.textContent = `${filteredStreams.length} transmiss√µes encontradas`;
            totalItems.textContent = filteredStreams.length;
            
            // Reseta para a primeira p√°gina
            currentPage = 1;
            renderCurrentPage();
        }

        /**
         * Fun√ß√£o para resetar todos os filtros
         * Limpa os campos de filtro e o objeto de filtros ativos
         */
        function resetFilters() {
            // Reseta os elementos de UI
            countryFilter.selectedIndex = 0;
            orientationFilter.selectedIndex = 0;
            tagsFilter.value = '';
            
            // Limpa o objeto de filtros ativos
            activeFilters.country = '';
            activeFilters.orientation = '';
            activeFilters.tags = [];
            
            // Atualiza a exibi√ß√£o de filtros ativos
            updateActiveFiltersDisplay();
        }

        /**
         * Fun√ß√£o para atualizar a exibi√ß√£o de filtros ativos
         * Cria badges para cada filtro ativo
         */
        function updateActiveFiltersDisplay() {
            // Limpa o container de filtros ativos
            activeFiltersContainer.innerHTML = '';
            
            // Adiciona badge para o filtro de pa√≠s, se ativo
            if (activeFilters.country) {
                addFilterBadge('Pa√≠s: ' + activeFilters.country, () => {
                    activeFilters.country = '';
                    countryFilter.selectedIndex = 0;
                    updateActiveFiltersDisplay();
                    applyFilters();
                });
            }
            
            // Adiciona badge para o filtro de orienta√ß√£o, se ativo
            if (activeFilters.orientation) {
                addFilterBadge('Orienta√ß√£o: ' + activeFilters.orientation, () => {
                    activeFilters.orientation = '';
                    orientationFilter.selectedIndex = 0;
                    updateActiveFiltersDisplay();
                    applyFilters();
                });
            }
            
            // Adiciona badges para cada tag, se houver
            activeFilters.tags.forEach(tag => {
                addFilterBadge('Tag: ' + tag, () => {
                    activeFilters.tags = activeFilters.tags.filter(t => t !== tag);
                    tagsFilter.value = activeFilters.tags.join(', ');
                    updateActiveFiltersDisplay();
                    applyFilters();
                });
            });
        }

        /**
         * Fun√ß√£o para adicionar uma badge de filtro
         * @param {string} text - Texto a ser exibido na badge
         * @param {Function} removeCallback - Fun√ß√£o a ser chamada quando a badge for removida
         */
        function addFilterBadge(text, removeCallback) {
            const badge = document.createElement('div');
            badge.className = 'filter-badge';
            badge.innerHTML = `
                ${text}
                <button class="remove-filter">√ó</button>
            `;
            badge.querySelector('.remove-filter').addEventListener('click', removeCallback);
            activeFiltersContainer.appendChild(badge);
        }

        // ==========================================
        // FUNCIONALIDADE DE PAGINA√á√ÉO
        // ==========================================
        
        /**
         * Fun√ß√£o para renderizar a p√°gina atual de transmiss√µes
         * Exibe os itens da p√°gina atual com base no √≠ndice de pagina√ß√£o
         */
        function renderCurrentPage() {
            // Calcula os √≠ndices de in√≠cio e fim para a p√°gina atual
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, filteredStreams.length);
            const currentPageItems = filteredStreams.slice(startIndex, endIndex);
            
            // Atualiza as informa√ß√µes de pagina√ß√£o
            showingFrom.textContent = filteredStreams.length > 0 ? startIndex + 1 : 0;
            showingTo.textContent = endIndex;
            currentPageEl.textContent = currentPage;
            
            // Habilita/desabilita os bot√µes de pagina√ß√£o
            prevPageBtn.disabled = currentPage === 1;
            nextPageBtn.disabled = endIndex >= filteredStreams.length;
            
            // Limpa o container de transmiss√µes
            streamsContainer.innerHTML = '';
            
            // Adiciona os cards de transmiss√£o
            currentPageItems.forEach(stream => {
                const card = createStreamCard(stream);
                streamsContainer.appendChild(card);
            });
            
            // Mostra mensagem se n√£o houver transmiss√µes
            if (currentPageItems.length === 0) {
                const noStreams = document.createElement('div');
                noStreams.style.textAlign = 'center';
                noStreams.style.padding = '20px';
                noStreams.style.color = '#aaa';
                noStreams.textContent = 'Nenhuma transmiss√£o encontrada com os filtros atuais.';
                streamsContainer.appendChild(noStreams);
            }
        }

        /**
         * Fun√ß√£o para criar um card de transmiss√£o
         * @param {Object} stream - Objeto com dados da transmiss√£o
         * @returns {HTMLElement} - Elemento DOM do card
         */
        function createStreamCard(stream) {
            // Cria o elemento do card
            const card = document.createElement('div');
            card.className = 'user-card';
            
            // Define valores padr√£o para propriedades que podem estar ausentes
            const profileImage = stream.profileImageURL || 'https://i.imgur.com/SL3HNQU.jpeg';
            const username = stream.username || 'Desconhecido';
            const viewers = stream.viewers || 0;
            const country = stream.country || 'Desconhecido';
            const orientation = stream.sexualOrientation || 'N√£o especificada';
            
            // Cria o HTML do card
            card.innerHTML = `
                <img src="${profileImage}" alt="${username}" onerror="this.src='https://i.imgur.com/SL3HNQU.jpeg'">
                <div class="user-info">
                    <div class="user-name">${username}</div>
                    <div class="user-details">
                        ${country} ‚Ä¢ ${orientation} ‚Ä¢ üëÅÔ∏è ${viewers}
                    </div>
                </div>
                <a href="#" class="view-stream">Ver</a>
            `;
            
            // Adiciona evento de clique ao bot√£o de visualiza√ß√£o
            card.querySelector('.view-stream').addEventListener('click', (e) => {
                e.preventDefault();
                openStreamModal(stream);
            });
            
            return card;
        }

        // ==========================================
        // FUNCIONALIDADE DO MODAL DE TRANSMISS√ÉO
        // ==========================================
        
        /**
         * Fun√ß√£o para abrir o modal de visualiza√ß√£o de transmiss√£o
         * @param {Object} stream - Objeto com dados da transmiss√£o
         */
        function openStreamModal(stream) {
            // Define o nome de usu√°rio no modal
            modalUsername.textContent = stream.username || 'Desconhecido';
            
            // Constr√≥i os detalhes da transmiss√£o
            let details = `
                <p><strong>Pa√≠s:</strong> ${stream.country || 'Desconhecido'}</p>
                <p><strong>Orienta√ß√£o:</strong> ${stream.sexualOrientation || 'N√£o especificada'}</p>
                <p><strong>Viewers:</strong> ${stream.viewers || 0}</p>
            `;
            
            // Adiciona tags, se dispon√≠veis
            if (stream.tags && stream.tags.length > 0) {
                details += `<p><strong>Tags:</strong> ${stream.tags.join(', ')}</p>`;
            }
            
            // Adiciona dados completos do broadcast, se dispon√≠veis
            if (stream.broadcastData) {
                details += `<p><strong>ID XCam:</strong> ${stream.broadcastData.XCamId || 'N/A'}</p>`;
                details += `<p><strong>Tipo de Transmiss√£o:</strong> ${stream.broadcastData.broadcastType || 'N/A'}</p>`;
                details += `<p><strong>G√™nero:</strong> ${stream.broadcastData.gender || 'N/A'}</p>`;
            }
            
            modalDetails.innerHTML = details;
            
            // Configura o player com iframe para a URL da transmiss√£o
            streamPlayer.innerHTML = '';
            
            // Cria o iframe para a transmiss√£o ao vivo
            const iframe = document.createElement('iframe');
            iframe.src = `https://xcam.gay/cam/?user=${stream.username}`;
            iframe.frameBorder = "0";
            iframe.allowFullscreen = true;
            iframe.allow = "autoplay; fullscreen";
            iframe.title = `Transmiss√£o de ${stream.username}`;
            
            // Adiciona o iframe ao player
            streamPlayer.appendChild(iframe);
            
            // Mostra o modal
            streamModal.showModal();
        }

        // Fecha o modal quando o bot√£o de fechar √© clicado
        closeModal.addEventListener('click', function() {
            streamModal.close();
            
            // Limpa o conte√∫do do player para interromper qualquer transmiss√£o
            streamPlayer.innerHTML = '';
        });

        // ==========================================
        // CONTROLES DE PAGINA√á√ÉO
        // ==========================================
        
        // Bot√£o de p√°gina anterior
        prevPageBtn.addEventListener('click', function() {
            if (currentPage > 1) {
                currentPage--;
                renderCurrentPage();
            }
        });

        // Bot√£o de pr√≥xima p√°gina
        nextPageBtn.addEventListener('click', function() {
            if ((currentPage * itemsPerPage) < filteredStreams.length) {
                currentPage++;
                renderCurrentPage();
            }
        });

        // ==========================================
        // CONTROLES DE FILTRO
        // ==========================================
        
        // Bot√£o para aplicar filtros
        applyFiltersBtn.addEventListener('click', function() {
            // Atualiza os filtros ativos com os valores selecionados
            activeFilters.country = countryFilter.value;
            activeFilters.orientation = orientationFilter.value;
            
            // Processa as tags (separadas por v√≠rgula)
            const tagsText = tagsFilter.value.trim();
            activeFilters.tags = tagsText ? 
                tagsText.split(',').map(tag => tag.trim()).filter(tag => tag) : 
                [];
            
            // Atualiza a exibi√ß√£o de filtros e aplica os filtros
            updateActiveFiltersDisplay();
            applyFilters();
        });

        // Bot√£o para limpar filtros
        clearFiltersBtn.addEventListener('click', function() {
            resetFilters();
            applyFilters();
        });

        // ==========================================
        // EVENTOS ADICIONAIS
        // ==========================================
        
        // Fecha o modal ao clicar no backdrop
        streamModal.addEventListener('click', function(event) {
            if (event.target === streamModal) {
                streamModal.close();
                
                // Limpa o conte√∫do do player para interromper qualquer transmiss√£o
                streamPlayer.innerHTML = '';
            }
        });

        // Inicializa com estado vazio
        resetFilters();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'942593a751fc0c61',t:'MTc0NzY3ODQ5Ni4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
